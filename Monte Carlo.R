rm(list=ls())
pi

mc.pi <- function(N=1e4){
  x = 2*runif(N)-1 ; y = 2*runif(N)-1
  pi_hat = (sum(x^2+y^2<=1)/N) * 4
  return(pi_hat)
}
mc.pi()

library(plotrix)
plot(x,y, asp = 1, xlim=c(-1,1), main="Monte Carlo")
draw.circle(0,0,1,lwd=1)

##Roll dice##
Roll_dice <- function(N=1e6){
  r = 0.02; T = 1; K = 4; pt= 5e5
  x = runif(N)
  x.rand = as.integer(x*6) + 1  # Select 1 to 6 randomly with probability 1/6 respectively.
  x.tf = ifelse(x.rand-K > 0, x.rand-K,0)
  price = mean(x.tf*5e5*exp(-r*T))
  return(price)
}
Roll_dice()
actual_price = ((4/6)*0 + (1/6)*1 + (1/6)*2)*5e5*exp(-0.02)
c(actual_price,Roll_dice(),abs(actual_price-Roll_dice()))

##Stock process
rm(list=ls())
N = 252; r = 0.02; vol = 0.3; T = 1 ; dt = T/N
S = numeric(N+1)
t = seq(from = 0, to = T, length.out = N+1)
S[1] = 230
phi = rnorm(N)
for (i in 2:(N+1)){
  S[i] = S[i-1]*exp((r-0.5*vol^2)*dt + vol*sqrt(dt)*phi[i-1])
}
plot(t,S, xlab = "Time", ylab = "Kospi200 index", 
     main="Kospi200 Generated By \nGeometric Brownian Motion")
lines(t,S)

##Stock process(50 indices)
rm(list=ls())
N = 252; r = 0.02; vol = 0.3; T = 1 ; dt = T/N
S = numeric(N+1)
t = seq(from = 0, to = T, length.out = N+1)
S[1] = 230
phi = rnorm
